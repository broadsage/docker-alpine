name: Manage Alpine Version Lifecycle

on:
  schedule:
    # Run weekly on Mondays at 9 AM UTC to check for new releases and EOL dates
    - cron: '0 9 * * 1'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: false
        type: choice
        options:
          - 'check-all'
          - 'check-new-releases'
          - 'check-eol'
        default: 'check-all'

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  detect-lifecycle-changes:
    runs-on: ubuntu-latest
    outputs:
      new_releases: ${{ steps.detect.outputs.new_releases }}
      eol_warnings: ${{ steps.detect.outputs.eol_warnings }}
      eol_reached: ${{ steps.detect.outputs.eol_reached }}
      has_new_releases: ${{ steps.detect.outputs.has_new_releases }}
      has_eol_warnings: ${{ steps.detect.outputs.has_eol_warnings }}
      has_eol_reached: ${{ steps.detect.outputs.has_eol_reached }}
    
    steps:
      - name: Harden the runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Detect version lifecycle changes
        id: detect
        env:
          ACTION: ${{ inputs.action || 'check-all' }}
        run: |
          set -uo pipefail
          
          echo "Fetching Alpine Linux release data from endoflife.date API..."
          
          # Fetch release data from endoflife.date product API (contains result.releases)
          RELEASES_FULL=$(curl -sSfL "https://endoflife.date/api/v1/products/alpine-linux/") || {
            echo "‚ùå Failed to fetch Alpine releases from endoflife.date product API"
            exit 1
          }

          # Extract the releases array (result.releases)
          RELEASES_JSON=$(echo "$RELEASES_FULL" | jq -c '.result.releases') || {
            echo "‚ùå Failed to parse releases array from API response"
            exit 1
          }
          
          echo "Parsing Alpine release data..."
          
          # Get all currently maintained versions (not EOL)
          # Use fields from the product API releases array
          SUPPORTED_VERSIONS=$(echo "$RELEASES_JSON" | \
            jq -r '.[] | select(.isMaintained == true) | .name')
          
          echo "Currently maintained Alpine versions:"
          echo "$SUPPORTED_VERSIONS"
          
          # Get currently tracked versions in this repo
          CURRENT_DIRS=$(find . -maxdepth 1 -type d -name "3.*" -o -name "edge" | \
            sed 's|^\./||' | grep -v "^\." | sort)
          
          echo ""
          echo "Currently tracked versions in repo:"
          echo "$CURRENT_DIRS"
          
          # Detect new releases (versions on Alpine site but not in repo)
          NEW_RELEASES=()
          for version in $SUPPORTED_VERSIONS; do
            # API returns version without 'v' prefix (e.g., "3.22")
            # Check if directory exists
            if [ ! -d "$version" ]; then
              echo "üÜï New release detected: $version"
              NEW_RELEASES+=("$version")
            fi
          done
          
          EOL_WARNINGS=()
          EOL_REACHED=()

          # Check EOL status for tracked versions using API data
          for dir in $CURRENT_DIRS; do
            # Skip edge - it is rolling/never EOL
            if [ "$dir" = "edge" ]; then
              continue
            fi

            # Get the release object for this version from the API
            VERSION_OBJ=$(echo "$RELEASES_JSON" | jq -r --arg ver "$dir" '.[] | select(.name == $ver)')
            if [ -z "$VERSION_OBJ" ]; then
              echo "‚ö†Ô∏è  Version $dir not present in API data"
              continue
            fi

            IS_EOL=$(echo "$VERSION_OBJ" | jq -r '.isEol')
            EOL_DATE=$(echo "$VERSION_OBJ" | jq -r '.eolFrom')

            if [ "$IS_EOL" = "true" ]; then
              echo "üõë Version $dir has reached EOL (${EOL_DATE})"
              EOL_REACHED+=("${dir}:${EOL_DATE}")
            else
              # Not EOL ‚Äî check if an EOL date exists and warn if within 30 days
              if [ "$EOL_DATE" != "null" ] && [ -n "$EOL_DATE" ]; then
                # Calculate days remaining using date(1)
                DAYS_LEFT=$(( ( $(date -d "$EOL_DATE" +%s) - $(date +%s) ) / 86400 )) || DAYS_LEFT=9999
                echo "Version $dir: EOL ${EOL_DATE} (${DAYS_LEFT} days left)"
                if [ $DAYS_LEFT -le 30 ] && [ $DAYS_LEFT -gt 0 ]; then
                  EOL_WARNINGS+=("${dir}:${EOL_DATE}:${DAYS_LEFT}")
                fi
              fi
            fi
          done
          
          # Output results
          if [ ${#NEW_RELEASES[@]} -gt 0 ]; then
            echo "has_new_releases=true" >> $GITHUB_OUTPUT
            NEW_JSON=$(printf '%s\n' "${NEW_RELEASES[@]}" | jq -R . | jq -s -c .)
            echo "new_releases=${NEW_JSON}" >> $GITHUB_OUTPUT
            echo "‚úÖ New releases detected: ${NEW_RELEASES[*]}"
          else
            echo "has_new_releases=false" >> $GITHUB_OUTPUT
            echo "new_releases=[]" >> $GITHUB_OUTPUT
            echo "‚úÖ No new releases detected"
          fi
          
          if [ ${#EOL_WARNINGS[@]} -gt 0 ]; then
            echo "has_eol_warnings=true" >> $GITHUB_OUTPUT
            EOL_WARN_JSON=$(printf '%s\n' "${EOL_WARNINGS[@]}" | jq -R . | jq -s -c .)
            echo "eol_warnings=${EOL_WARN_JSON}" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  EOL warnings: ${EOL_WARNINGS[*]}"
          else
            echo "has_eol_warnings=false" >> $GITHUB_OUTPUT
            echo "eol_warnings=[]" >> $GITHUB_OUTPUT
            echo "‚úÖ No EOL warnings"
          fi
          
          if [ ${#EOL_REACHED[@]} -gt 0 ]; then
            echo "has_eol_reached=true" >> $GITHUB_OUTPUT
            EOL_REACHED_JSON=$(printf '%s\n' "${EOL_REACHED[@]}" | jq -R . | jq -s -c .)
            echo "eol_reached=${EOL_REACHED_JSON}" >> $GITHUB_OUTPUT
            echo "üõë EOL reached: ${EOL_REACHED[*]}"
          else
            echo "has_eol_reached=false" >> $GITHUB_OUTPUT
            echo "eol_reached=[]" >> $GITHUB_OUTPUT
            echo "‚úÖ No versions past EOL"
          fi

  scaffold-new-version:
    needs: detect-lifecycle-changes
    if: needs.detect-lifecycle-changes.outputs.has_new_releases == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        version: ${{ fromJson(needs.detect-lifecycle-changes.outputs.new_releases) }}
    
    steps:
      - name: Harden the runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y lua5.3 liblua5.3-dev luarocks
          sudo luarocks install http
          sudo luarocks install lyaml
          sudo luarocks install luafilesystem
          sudo luarocks install cqueues

      - name: Prepare new version using prepare-branch.sh
        env:
          NEW_VERSION: ${{ matrix.version }}
        run: |
          echo "Preparing Alpine ${NEW_VERSION} using prepare-branch.sh..."
          
          # Convert 3.22 to v3.22 for Alpine branch name
          ALPINE_BRANCH="v${NEW_VERSION}"
          
          # Run the prepare-branch.sh script with 'all' command
          # This fetches minirootfs, creates Dockerfiles, and organizes into version/arch structure
          chmod +x prepare-branch.sh
          ./prepare-branch.sh all "${ALPINE_BRANCH}"
          
          echo "‚úÖ Successfully prepared ${NEW_VERSION}"
          
          # Show the created structure
          tree -L 2 "${NEW_VERSION}" || find "${NEW_VERSION}" -type f

      - name: Upload artifact
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v4.6.0
        with:
          name: new-version-${{ matrix.version }}
          path: |
            ${{ matrix.version }}/
          retention-days: 7

  create-new-version-pr:
    needs: [detect-lifecycle-changes, scaffold-new-version]
    if: needs.detect-lifecycle-changes.outputs.has_new_releases == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Harden the runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Download all new version artifacts
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4.1.8
        with:
          path: artifacts

      - name: Copy new versions
        run: |
          for dir in artifacts/new-version-*; do
            if [ -d "$dir" ]; then
              version=$(basename "$dir" | sed 's/new-version-//')
              echo "Copying new version: $version"
              cp -r "$dir/"* "$version/" || true
            fi
          done

      - name: Verify changes
        run: |
          git status
          git diff --stat

      - name: Create Pull Request for new versions
        uses: peter-evans/create-pull-request@5e914681df9dc83aa4e4905692ca88beb2f9e91f # v7.0.5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            feat: Add support for new Alpine Linux versions
            
            New versions detected: ${{ join(fromJson(needs.detect-lifecycle-changes.outputs.new_releases), ', ') }}
            
            Automatically scaffolded directory structure and Dockerfiles.
          branch: alpine-new-versions-${{ github.run_number }}
          delete-branch: true
          title: 'üÜï Add support for new Alpine Linux versions'
          body: |
            ## üèîÔ∏è New Alpine Linux Version Support
            
            This PR adds support for newly released Alpine Linux versions.
            
            ### üì¶ New Versions
            
            ${{ join(fromJson(needs.detect-lifecycle-changes.outputs.new_releases), ', ') }}
            
            ### üîß What's Included
            
            - ‚úÖ Directory structure for all architectures
            - ‚úÖ Placeholder Dockerfiles (version will be updated by sync workflow)
            - ‚úÖ VERSION file with initial release version
            
            ### ‚úîÔ∏è Next Steps
            
            1. **Review the scaffolded structure** - Ensure all architectures are present
            2. **Merge this PR** - This adds the new version directories
            3. **Sync workflow will run** - Within 12 hours, the sync workflow will:
               - Fetch actual minirootfs archives
               - Update VERSION files with correct patch versions
               - Update Dockerfiles with correct archive names
            4. **Build workflow triggers** - Images will be built and pushed to GHCR
            
            ### üìã Manual Tasks (if needed)
            
            - [ ] Check if new architectures were added (e.g., new riscv64 support)
            - [ ] Update dependabot.yml if needed (already uses directory wildcard)
            - [ ] Review Alpine release notes for breaking changes
            
            ### ü§ñ Automation
            
            This PR was automatically created by the `manage-alpine-versions` workflow.
            - **Triggered**: ${{ github.event_name }}
            - **Run ID**: ${{ github.run_id }}
            
            ---
            
            *Automated by manage-alpine-versions workflow*
          labels: |
            alpine-new-version
            enhancement
            automated
          assignees: ${{ github.repository_owner }}
          reviewers: ${{ github.repository_owner }}

  create-eol-warning-issues:
    needs: detect-lifecycle-changes
    if: needs.detect-lifecycle-changes.outputs.has_eol_warnings == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        warning: ${{ fromJson(needs.detect-lifecycle-changes.outputs.eol_warnings) }}
    
    steps:
      - name: Harden the runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Parse warning data
        id: parse
        env:
          WARNING_DATA: ${{ matrix.warning }}
        run: |
          # Format: version:eol_date:days_remaining
          IFS=':' read -r VERSION EOL_DATE DAYS <<< "$WARNING_DATA"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "eol_date=${EOL_DATE}" >> $GITHUB_OUTPUT
          echo "days=${DAYS}" >> $GITHUB_OUTPUT

      - name: Ensure EOL warning issue exists (create if missing)
        uses: actions/github-script@v6
        env:
          VERSION: ${{ steps.parse.outputs.version }}
          EOL_DATE: ${{ steps.parse.outputs.eol_date }}
          DAYS: ${{ steps.parse.outputs.days }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const version = process.env.VERSION;
            const eolDate = process.env.EOL_DATE;
            const days = process.env.DAYS;
            const title = `‚ö†Ô∏è Alpine ${version} approaching EOL`;

            // Check for existing open issues with the same title
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            if (issues.some(i => i.title === title)) {
              core.info(`Issue already exists for ${version}`);
            } else {
              core.info(`Creating EOL warning issue for ${version}`);
              const body = `## Alpine Linux ${version} End of Life Warning\n\nAlpine Linux ${version} will reach End of Life (EOL) in **${days} days** on **${eolDate}**.\n\n### Actions Required\n\n- [ ] Review if we should continue supporting ${version} post-EOL\n- [ ] Check if any users specifically need ${version}\n- [ ] Plan migration path to newer versions\n- [ ] Prepare deprecation PR when EOL is reached\n\n---\n\n*This issue was automatically created by the manage-alpine-versions workflow*`;

              // Ensure labels exist with desired colors
              const labelsToEnsure = [
                { name: 'alpine-eol', color: 'ffcc00', description: 'Alpine EOL warnings' },
                { name: 'maintenance', color: '1d76db', description: 'Maintenance related tasks' }
              ];

              for (const lbl of labelsToEnsure) {
                try {
                  await github.rest.issues.getLabel({ owner: context.repo.owner, repo: context.repo.repo, name: lbl.name });
                } catch (err) {
                  // Label does not exist - create it
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: lbl.name,
                    color: lbl.color,
                    description: lbl.description
                  });
                }
              }

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: labelsToEnsure.map(l => l.name)
              });
            }

  deprecate-eol-versions:
    needs: detect-lifecycle-changes
    if: needs.detect-lifecycle-changes.outputs.has_eol_reached == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Harden the runner
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Prepare EOL deprecation
        id: prepare
        env:
          EOL_VERSIONS: ${{ needs.detect-lifecycle-changes.outputs.eol_reached }}
        run: |
          echo "Preparing deprecation for EOL versions..."
          
          # Parse the EOL versions array
          VERSIONS=$(echo "$EOL_VERSIONS" | jq -r '.[]' | cut -d: -f1)
          VERSIONS_FORMATTED=$(echo "$VERSIONS" | tr '\n' ',' | sed 's/,$//' | sed 's/,/, /g')
          
          echo "versions_list=${VERSIONS_FORMATTED}" >> $GITHUB_OUTPUT
          
          # Create deprecation notice
          cat > DEPRECATION_NOTICE.md <<EOF
          # Alpine Linux Version Deprecation Notice

          The following Alpine Linux versions have reached their End of Life (EOL) date:

          EOF
          
          for version_data in $(echo "$EOL_VERSIONS" | jq -r '.[]'); do
            IFS=':' read -r version eol_date <<< "$version_data"
            echo "- **Alpine ${version}** - EOL: ${eol_date}" >> DEPRECATION_NOTICE.md
          done
          
          cat >> DEPRECATION_NOTICE.md <<EOF

          These versions are no longer receiving security updates from the Alpine Linux project.

          ## Recommended Actions

          - Migrate to a supported version (latest stable or edge)
          - Update your Dockerfiles to use a newer Alpine base
          - Review Alpine's [release schedule](https://alpinelinux.org/releases/)

          ## Timeline

          - **Now**: Versions marked as deprecated
          - **+30 days**: Versions will be removed from this repository
          - **+60 days**: Historical images may be pruned from registries

          EOF

      - name: Create Pull Request for EOL deprecation
        uses: peter-evans/create-pull-request@5e914681df9dc83aa4e4905692ca88beb2f9e91f # v7.0.5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            chore: Deprecate EOL Alpine Linux versions
            
            Versions that reached EOL: ${{ steps.prepare.outputs.versions_list }}
            
            These versions are no longer supported by Alpine Linux.
          branch: alpine-eol-deprecation-${{ github.run_number }}
          delete-branch: true
          title: 'üõë Deprecate EOL Alpine Linux versions'
          body: |
            ## üõë End of Life Version Deprecation
            
            This PR deprecates Alpine Linux versions that have reached their End of Life (EOL) date.
            
            ### üì¶ Affected Versions
            
            ${{ steps.prepare.outputs.versions_list }}
            
            ### ‚ö†Ô∏è Important
            
            These versions are **no longer receiving security updates** from the Alpine Linux project.
            
            ### üîß What This PR Does
            
            - ‚úÖ Adds deprecation notice to repository
            - ‚ö†Ô∏è **Does NOT remove** version directories yet (grace period)
            - ‚ÑπÔ∏è Documents EOL status for users
            
            ### üìã Next Steps After Merge
            
            1. **Immediate**: Users are notified via deprecation notice
            2. **+30 days**: Create PR to remove EOL version directories
            3. **+60 days**: Consider pruning old images from registries
            
            ### üîó References
            
            - [Alpine Linux Release Schedule](https://alpinelinux.org/releases/)
            - [Alpine Security Policy](https://security.alpinelinux.org/)
            
            ### ü§ñ Automation
            
            This PR was automatically created by the `manage-alpine-versions` workflow.
            - **Triggered**: ${{ github.event_name }}
            - **Run ID**: ${{ github.run_id }}
            
            ---
            
            *Automated by manage-alpine-versions workflow*
          labels: |
            alpine-eol
            deprecation
            maintenance
          assignees: ${{ github.repository_owner }}
          reviewers: ${{ github.repository_owner }}
